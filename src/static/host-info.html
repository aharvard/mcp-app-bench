<!DOCTYPE html>
<html>
  <head>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Instrument+Serif:ital@0;1&family=Victor+Mono:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="{{BASE_URL}}/shell/shell.css?v={{CACHE_HASH}}">
  </head>
  <body>
    <!-- Loading State -->
    <div id="app-loading" class="app-loading">
      <div class="app-loading-spinner"></div>
      <div class="app-loading-text">Waiting for tool result...</div>
    </div>

    <!-- Main Content (hidden until ready) -->
    <div id="app-content" class="app-content">
      <h1>Host Info Inspector</h1>
      <p class="host-info-subtitle" id="host-info-subtitle">Connecting...</p>
      
      <div class="terminal">
        <div class="terminal-grid">
          <div class="terminal-section">
            <h2>HostContext Validation</h2>
            <div id="test-runner-content" class="test-runner">
              <div class="test-summary">
                <div class="test-summary-status is-running">
                  <div class="test-summary-spinner"></div>
                  <span>Running tests...</span>
                </div>
              </div>
            </div>
          </div>
        </div>
        <div id="inspector-footer" class="inspector-footer"></div>
      </div>
    </div>

    <script src="{{BASE_URL}}/shell/shell.js?v={{CACHE_HASH}}"></script>
    <script>
      (function () {
        // Test state
        let testCases = [];
        let testResults = [];
        let unexpectedProps = [];
        let currentTestIndex = 0;
        let isRunning = false;

        // Group tests by their top-level property
        function groupTestsByProperty(tests, results) {
          const groups = {};
          
          tests.forEach(function(test, index) {
            // Get the second-level property (e.g., "hostContext.theme" -> "theme")
            const parts = test.path.split('.');
            const groupKey = parts.length > 1 ? parts[1] : parts[0];
            
            if (!groups[groupKey]) {
              groups[groupKey] = {
                name: groupKey,
                tests: [],
                results: []
              };
            }
            
            groups[groupKey].tests.push(test);
            groups[groupKey].results.push(results[index] || null);
          });
          
          return Object.values(groups);
        }

        // Get group status based on test results
        function getGroupStatus(results) {
          const validResults = results.filter(function(r) { return r !== null; });
          if (validResults.length === 0) return 'pending';
          
          const hasInvalid = validResults.some(function(r) { return r.status === 'invalid'; });
          const hasWarn = validResults.some(function(r) { return r.status === 'warn'; });
          const providedCount = validResults.filter(function(r) { return r.status === 'provided' || r.status === 'warn'; }).length;
          
          if (hasInvalid) return 'invalid';
          if (providedCount === 0) return 'missing';
          if (hasWarn) return 'warn';
          if (providedCount === validResults.length) return 'complete';
          return 'partial';
        }

        // Get status icon
        function getStatusIcon(status) {
          switch (status) {
            case 'provided': return '✓';
            case 'complete': return '✓';
            case 'partial': return '◐';
            case 'missing': return '○';
            case 'invalid': return '✗';
            case 'warn': return '⚠';
            case 'pending': return '○';
            default: return '○';
          }
        }

        // Get group icon class
        function getGroupIconClass(status) {
          switch (status) {
            case 'complete': return 'is-provided';
            case 'partial': return 'is-provided';
            case 'missing': return 'is-missing';
            case 'invalid': return 'is-invalid';
            case 'warn': return 'is-warn';
            default: return 'is-pending';
          }
        }

        // Format path for display (highlight leaf)
        function formatPath(path) {
          const parts = path.split('.');
          if (parts.length <= 2) {
            return '<span class="test-item-path-leaf">' + MCPAppShell.escapeHtml(path) + '</span>';
          }
          
          const leaf = parts.pop();
          const prefix = parts.join('.');
          return '<span class="test-item-path-segment">' + MCPAppShell.escapeHtml(prefix) + '.</span>' +
                 '<span class="test-item-path-leaf">' + MCPAppShell.escapeHtml(leaf) + '</span>';
        }

        // Render the test runner UI
        function renderTestRunner() {
          const container = document.getElementById('test-runner-content');
          if (!container) return;

          const groups = groupTestsByProperty(testCases, testResults);
          
          // Calculate summary counts
          const providedCount = testResults.filter(function(r) { return r && r.status === 'provided'; }).length;
          const missingCount = testResults.filter(function(r) { return r && r.status === 'missing'; }).length;
          const invalidCount = testResults.filter(function(r) { return r && r.status === 'invalid'; }).length;
          const warnCount = testResults.filter(function(r) { return r && r.status === 'warn'; }).length;
          const totalTests = testCases.length;
          const completedTests = testResults.filter(function(r) { return r !== null; }).length;

          // Calculate coverage percentage (provided + warn count as "covered")
          const coveredCount = providedCount + warnCount;
          const percentage = totalTests > 0 ? Math.round((coveredCount / totalTests) * 100) : 0;
          const grade = MCPAppShell.getGrade(percentage);

          let html = '';

          // Grade display
          if (!isRunning && completedTests === totalTests) {
            html += '<div class="test-grade">';
            html += '<div class="test-grade-circle is-' + grade.color + '">' + grade.letter + '</div>';
            html += '<div class="test-grade-info">';
            html += '<div class="test-grade-title">HostContext Coverage</div>';
            html += '<div class="test-grade-subtitle">';
            html += '<span class="test-grade-percentage">' + percentage + '%</span> of spec properties provided';
            html += '</div>';
            html += '<div class="test-summary-counts">';
            html += '<span class="test-count is-provided"><span class="test-count-value">' + coveredCount + '</span> provided</span>';
            html += '<span class="test-count is-missing"><span class="test-count-value">' + missingCount + '</span> missing</span>';
            if (invalidCount > 0) {
              html += '<span class="test-count is-invalid"><span class="test-count-value">' + invalidCount + '</span> invalid</span>';
            }
            if (unexpectedProps.length > 0) {
              html += '<span class="test-count is-extra"><span class="test-count-value">' + unexpectedProps.length + '</span> extra</span>';
            }
            html += '</div>';
            html += '</div>';
            html += '</div>';
          } else {
            // Running state
            html += '<div class="test-grade">';
            html += '<div class="test-grade-circle is-warn" style="border-style: dashed;">';
            html += '<div class="app-loading-spinner" style="width: 24px; height: 24px; border-width: 2px;"></div>';
            html += '</div>';
            html += '<div class="test-grade-info">';
            html += '<div class="test-grade-title">Checking conformance...</div>';
            html += '<div class="test-grade-subtitle">' + completedTests + ' / ' + totalTests + ' properties checked</div>';
            html += '</div>';
            html += '</div>';
          }

          // Test groups
          html += '<div class="test-groups">';
          
          groups.forEach(function(group) {
            const groupStatus = getGroupStatus(group.results);
            const groupProvidedCount = group.results.filter(function(r) { return r && (r.status === 'provided' || r.status === 'warn'); }).length;
            const groupInvalidCount = group.results.filter(function(r) { return r && r.status === 'invalid'; }).length;
            
            // Auto-expand groups with issues
            const shouldExpand = groupStatus === 'invalid' || groupStatus === 'warn';
            
            html += '<div class="test-group' + (shouldExpand ? ' is-expanded' : '') + '" data-group="' + MCPAppShell.escapeHtml(group.name) + '">';
            
            // Group header
            html += '<div class="test-group-header">';
            html += '<span class="test-group-toggle">▶</span>';
            html += '<span class="test-group-icon ' + getGroupIconClass(groupStatus) + '">' + getStatusIcon(groupStatus) + '</span>';
            html += '<span class="test-group-name">' + MCPAppShell.escapeHtml(group.name) + '</span>';
            
            // Badge showing coverage
            let badgeText = groupProvidedCount + '/' + group.tests.length;
            let badgeClass = 'is-pass';
            if (groupInvalidCount > 0) {
              badgeClass = 'is-fail';
            } else if (groupProvidedCount === 0) {
              badgeClass = '';
            }
            html += '<span class="test-group-badge ' + badgeClass + '">' + badgeText + '</span>';
            html += '</div>';
            
            // Group content (individual tests)
            html += '<div class="test-group-content">';
            
            group.tests.forEach(function(test, i) {
              const result = group.results[i];
              const status = result ? result.status : 'pending';
              
              html += '<div class="test-item">';
              html += '<span class="test-item-icon is-' + status + '">' + getStatusIcon(status) + '</span>';
              html += '<span class="test-item-path">' + formatPath(test.path) + '</span>';
              html += '<span class="test-item-result">';
              
              if (result) {
                if (result.status === 'provided') {
                  html += '<span class="test-item-value">' + MCPAppShell.escapeHtml(MCPAppShell.formatTestValue(result.actualValue, 30)) + '</span>';
                } else if (result.status === 'missing') {
                  html += '<span class="test-item-message">' + MCPAppShell.escapeHtml(result.message) + '</span>';
                } else if (result.status === 'invalid') {
                  html += '<span class="test-item-message is-invalid">' + MCPAppShell.escapeHtml(result.message) + '</span>';
                } else if (result.status === 'warn') {
                  html += '<span class="test-item-message is-warn">' + MCPAppShell.escapeHtml(result.message) + '</span>';
                }
              }
              
              html += '</span>';
              html += '</div>';
            });
            
            html += '</div>'; // test-group-content
            html += '</div>'; // test-group
          });
          
          html += '</div>'; // test-groups

          // Unexpected properties section
          if (unexpectedProps.length > 0) {
            html += '<div class="test-unexpected">';
            html += '<div class="test-unexpected-header">';
            html += '<span>⚡</span>';
            html += '<span>Unexpected Properties (' + unexpectedProps.length + ')</span>';
            html += '</div>';
            
            html += '<div class="test-unexpected-list">';
            unexpectedProps.forEach(function(prop) {
              html += '<div class="test-unexpected-item">';
              html += '<span class="test-unexpected-path">' + MCPAppShell.escapeHtml(prop.path) + '</span>';
              html += '<span class="test-unexpected-value">' + MCPAppShell.escapeHtml(MCPAppShell.formatTestValue(prop.value, 30)) + '</span>';
              html += '</div>';
            });
            html += '</div>';
            html += '</div>';
          }

          // Raw data explorer
          const hostInfo = MCPAppShell.getHostInfo();
          if (hostInfo) {
            html += '<div class="test-raw-data" id="raw-data-section">';
            html += '<div class="test-raw-data-header">';
            html += '<span class="test-raw-data-toggle">▶</span>';
            html += '<span class="test-raw-data-title">Raw Host Data</span>';
            html += '</div>';
            html += '<div class="test-raw-data-content" id="raw-data-content"></div>';
            html += '</div>';
          }

          container.innerHTML = html;

          // Render raw JSON (collapsed to depth 2)
          if (hostInfo) {
            MCPAppShell.renderCollapsibleJson('raw-data-content', hostInfo, 2);
          }

          // Setup group toggle handlers
          container.querySelectorAll('.test-group-header').forEach(function(header) {
            header.addEventListener('click', function() {
              header.parentElement.classList.toggle('is-expanded');
            });
          });

          // Setup raw data toggle handler
          var rawDataSection = document.getElementById('raw-data-section');
          if (rawDataSection) {
            var rawDataHeader = rawDataSection.querySelector('.test-raw-data-header');
            if (rawDataHeader) {
              rawDataHeader.addEventListener('click', function() {
                rawDataSection.classList.toggle('is-expanded');
              });
            }
          }

          MCPAppShell.sendSizeChanged();
        }

        // Run tests with animation
        function runTests() {
          const hostInfo = MCPAppShell.getHostInfo();
          if (!hostInfo) return;

          // Generate test cases from schema
          testCases = MCPAppShell.generateTestCases(MCPAppShell.hostContextSchema, '');
          testResults = new Array(testCases.length).fill(null);
          
          // Find unexpected properties
          unexpectedProps = MCPAppShell.findUnexpectedProperties(
            { hostContext: hostInfo.hostContext },
            MCPAppShell.hostContextSchema,
            ''
          );

          isRunning = true;
          currentTestIndex = 0;

          // Initial render
          renderTestRunner();

          // Run tests with staggered timing for visual effect
          function runNextTest() {
            if (currentTestIndex >= testCases.length) {
              isRunning = false;
              renderTestRunner();
              return;
            }

            const test = testCases[currentTestIndex];
            const result = MCPAppShell.runTestCase(test, { hostContext: hostInfo.hostContext });
            testResults[currentTestIndex] = result;
            currentTestIndex++;

            renderTestRunner();

            // Small delay between tests for visual feedback
            const delay = result.status === 'provided' ? 15 : 25;
            setTimeout(runNextTest, delay);
          }

          // Start running tests
          setTimeout(runNextTest, 100);
        }

        // Initialize
        MCPAppShell.initialize({
          clientName: 'Host Info Inspector',
          clientVersion: '1.0.0',
          onInitialized: function (result) {
            // Content will render when tool-result is received
          }
        });

        // Listen for tool result to start tests
        window.addEventListener('mcp-tool-result', function () {
          runTests();
          MCPAppShell.setupInspectorFooter('inspect-host-info');
        });

        // Listen for host context changes
        window.addEventListener('mcp-host-context-changed', function () {
          if (MCPAppShell.isReady()) {
            // Re-run tests when host context changes
            runTests();
          }
        });
      })();
    </script>
  </body>
</html>
